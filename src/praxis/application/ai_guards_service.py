"""Application service for AI guards composition and rendering."""

from __future__ import annotations

from pathlib import Path

from praxis.domain.ai_guards import (
    AIVendor,
    GuardComposition,
    GuardValidationIssue,
    GuardValidationResult,
    RenderedGuard,
)
from praxis.infrastructure.ai_guards_loader import (
    load_environment_config,
    load_project_domain_guards,
    load_user_core_guard,
    load_user_env_guard,
    load_user_tools_guard,
)


def compose_guards(
    domain: str,
    project_path: Path | None = None,
) -> GuardComposition:
    """Compose AI guards from user and project sources.

    Composition order:
    1. User core guards (~/.ai-guards/core.md)
    2. User environment overlay (~/.ai-guards/env/{home|work}.md)
    3. User tool mappings (~/.ai-guards/tools.md)
    4. Project domain guards (praxis/ai-guards/{domain}.md)

    Args:
        domain: Project domain (code, create, write, etc.)
        project_path: Path to project root (defaults to cwd)

    Returns:
        GuardComposition with all applicable guards
    """
    # Load environment config
    env_config = load_environment_config()

    # Load user-level guards
    user_core = load_user_core_guard()
    user_tools = load_user_tools_guard()
    user_env = load_user_env_guard(env_config.active_environment)

    # Load project-level guards
    project_guards = load_project_domain_guards(domain, project_path)

    # Build composition order for debugging
    composition_order = []
    if user_core:
        composition_order.append("user_core")
    if user_env:
        composition_order.append(f"user_env ({env_config.active_environment})")
    if user_tools:
        composition_order.append("user_tools")
    if project_guards:
        composition_order.append(f"project ({domain})")

    return GuardComposition(
        user_core=user_core,
        user_tools=user_tools,
        user_env=user_env,
        project_guards=project_guards,
        environment=env_config.active_environment,
        composition_order=composition_order,
    )


def render_guard_for_vendor(
    composition: GuardComposition,
    vendor: AIVendor,
) -> RenderedGuard:
    """Render a guard composition for a specific AI vendor.

    Args:
        composition: Composed guards from multiple sources
        vendor: Target AI vendor

    Returns:
        RenderedGuard with vendor-specific filename and content
    """
    # Determine output filename based on vendor
    filename_map = {
        AIVendor.CLAUDE: "CLAUDE.md",
        AIVendor.COPILOT: ".github/copilot-instructions.md",
        AIVendor.GEMINI: "GEMINI.md",
    }
    filename = filename_map[vendor]

    # Compose content from all guards
    content_parts = []
    warnings = []

    # Add header
    content_parts.append(f"# AI Instructions for {vendor.value.title()}\n")
    content_parts.append(
        "<!-- This file is auto-generated by Praxis AI Guards. -->\n"
        "<!-- Do not edit manually. Run `praxis guards render` to regenerate. -->\n"
    )

    # Add user core guards
    if composition.user_core and composition.user_core.content:
        content_parts.append("\n## User Core Guards\n")
        content_parts.append(composition.user_core.content)
    else:
        warnings.append("No user core guards found (~/.ai-guards/core.md)")

    # Add environment overlay
    if composition.user_env and composition.user_env.content:
        content_parts.append(
            f"\n## Environment Overlay ({composition.environment.title()})\n"
        )
        content_parts.append(composition.user_env.content)

    # Add user tool mappings
    if composition.user_tools and composition.user_tools.content:
        content_parts.append("\n## Tool Mappings\n")
        content_parts.append(composition.user_tools.content)

    # Add project guards
    for guard in composition.project_guards:
        if guard.content:
            content_parts.append(f"\n## Project Guards: {guard.domain}\n")
            content_parts.append(guard.content)

    # If no guards at all, add minimal content
    if not any(
        [
            composition.user_core,
            composition.user_env,
            composition.user_tools,
            composition.project_guards,
        ]
    ):
        warnings.append("No guards found at any level")
        content_parts.append(
            "\n## No Guards Configured\n\n"
            "No AI guards are currently configured. "
            "See the Praxis documentation for setup instructions.\n"
        )

    content = "\n".join(content_parts)

    return RenderedGuard(
        vendor=vendor,
        filename=filename,
        content=content,
        composition=composition,
        warnings=warnings,
    )


def validate_guard_composition(composition: GuardComposition) -> GuardValidationResult:
    """Validate a guard composition.

    Checks for:
    - Missing critical guards
    - Environment leakage (home→work references)
    - Conflicting instructions

    Args:
        composition: The composition to validate

    Returns:
        GuardValidationResult with any issues found
    """
    issues = []

    # Check if any guards exist
    if not composition.all_guards:
        issues.append(
            GuardValidationIssue(
                severity="warning",
                message="No AI guards configured at any level",
            )
        )

    # Check for user core guards (recommended but not required)
    if not composition.user_core:
        issues.append(
            GuardValidationIssue(
                severity="info",
                message=(
                    "No user core guards found. "
                    "Consider creating ~/.ai-guards/core.md"
                ),
            )
        )

    # Check for environment leakage
    # Work environment should not reference home-specific tools/paths
    if composition.environment == "work":
        for guard in composition.all_guards:
            if guard.content:
                # Simple heuristic: check for common home-specific references
                home_indicators = [
                    "~/personal",
                    "~/home",
                    "/Users/",
                    "C:\\Users\\",
                ]
                for indicator in home_indicators:
                    if indicator in guard.content:
                        issues.append(
                            GuardValidationIssue(
                                severity="warning",
                                message=(
                                    f"Possible environment leakage: "
                                    f"'{indicator}' found in {guard.level.value} "
                                    f"while in work environment"
                                ),
                                guard_file=str(guard.path),
                            )
                        )
                        break  # Only warn once per file

    # Validation passes if no errors (warnings/info are okay)
    valid = not any(i.severity == "error" for i in issues)

    return GuardValidationResult(
        valid=valid,
        issues=issues,
        composition=composition,
    )


def list_active_guards(
    domain: str,
    project_path: Path | None = None,
) -> list[str]:
    """List active guard files for a project.

    Args:
        domain: Project domain
        project_path: Path to project root (defaults to cwd)

    Returns:
        List of active guard file descriptions
    """
    composition = compose_guards(domain, project_path)
    descriptions = []

    env_config = load_environment_config()
    descriptions.append(f"Active environment: {env_config.active_environment}")

    for guard in composition.all_guards:
        status = "✓" if guard.exists else "✗"
        descriptions.append(f"{status} {guard.level.value}: {guard.path}")

    return descriptions
