Multi-Agent Development with Claude, Copilot, and Agentic Tools

Last updated: 2025-12-28

Purpose

This document consolidates best practices and practical guidance for running multiple AI agents in parallel during software development. It focuses on Claude Code as the primary orchestrator, with comparisons to GitHub Copilot and agentic frameworks (e.g., Antigravity), and formalizes the mental model of Claude as a foreman rather than an autonomous manager.

⸻

Core Question

Can modern AI coding tools autonomously schedule, manage, and integrate multiple agents and git worktrees?

Short answer: No.

Long answer: Current tools can procedurally orchestrate work when explicitly instructed, but none own the execution loop end-to-end.

⸻

Best Practices for Multi-Agent Work

1. Prefer Git Worktrees
	•	One worktree per agent
	•	One branch per agent
	•	Clean isolation with shared repository history

Example:

git worktree add ../proj-agent-a -b agent/a
git worktree add ../proj-agent-b -b agent/b

cd ../proj-agent-a && claude
cd ../proj-agent-b && claude


⸻

2. Enforce Explicit Ownership Boundaries

Define file- and responsibility-level ownership to avoid merge conflicts:
	•	Agent A owns src/service_a/**
	•	Agent B owns src/service_b/**
	•	Only one agent modifies lockfiles (poetry.lock, package-lock.json, etc.)

⸻

3. Maintain a Single Authoritative Spec

All agents work from:
	•	one shared spec
	•	clear goals and non-goals

Each agent must produce a handoff summary:
	•	summary of changes
	•	list of files touched
	•	how to run tests
	•	assumptions and open questions

⸻

4. Isolate Runtime Resources

Common collision points:
	•	ports
	•	databases
	•	containers
	•	caches and virtual environments

Mitigations:
	•	per-agent PORT
	•	per-agent COMPOSE_PROJECT_NAME
	•	per-worktree virtualenvs

⸻

5. Centralize Integration

Agents:
	•	implement changes
	•	run self-tests
	•	stop

Integration:
	•	happens once
	•	intentionally
	•	via a human or a dedicated integration agent

⸻

Claude Code Capabilities

Claude can:
	•	create and manage git worktrees (when instructed)
	•	spawn sub-agents with scoped roles
	•	follow explicit rules and ownership boundaries
	•	review work against the original intent and spec

Claude cannot:
	•	autonomously schedule work
	•	persist orchestration state across sessions
	•	continuously monitor repository state
	•	enforce locks or merge policies without external tooling

⸻

Tool Comparison

Claude Code

Role: Foreman
	•	Strong task decomposition
	•	High adherence to rules and constraints
	•	Good spec-to-execution fidelity
	•	No autonomous control loop

GitHub Copilot

Role: Worker / Pair Programmer
	•	Reactive and editor-local
	•	No awareness of agent lifecycles
	•	No orchestration or coordination capabilities

Antigravity / Agentic Frameworks

Role: Research-Grade Coordinator
	•	Can model agent graphs and task flows
	•	Require significant glue code
	•	Fragile without strong guardrails
	•	Not production-hardened

⸻

The Foreman Mental Model

A foreman:
	•	reads and interprets the plan
	•	breaks work into tasks
	•	assigns tasks to specialists
	•	enforces boundaries
	•	reviews output before integration

Claude performs best when used explicitly in this role.

A foreman does not:
	•	decide when work begins
	•	run continuously or autonomously
	•	merge code without oversight
	•	hold final authority

That authority remains external (human, scripts, CI).

⸻

Practical Architecture

Claude = Brain
Git + Shell = Hands
Human = Authority

This separation reflects the current state of AI-assisted development.

⸻

Bottom Line
	•	No current AI tool fully owns the multi-agent execution loop
	•	Claude Code is the strongest procedural orchestrator available today
	•	True autonomy requires an external scheduler and policy engine

Until that exists, treat AI systems as high-leverage foremen, not managers.

⸻

Optional Next Steps
	•	Create a reusable MULTI_AGENT_PLAYBOOK.md
	•	Add an agentctl.sh wrapper for worktree management
	•	Define and standardize an agent handoff template

⸻

End of document.
