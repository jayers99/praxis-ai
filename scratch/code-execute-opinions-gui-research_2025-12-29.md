# Python Cross-Platform GUI Applications for RESTful API Calls - Code Opinions Research

_Date: 2025-12-29_
_Timebox: 120 minutes_
_Seeds: None_

## Executive Summary

- **Framework Consensus (High)**: PyQt/PySide dominates mature, feature-rich GUI development, with PySide6 recommended for commercial closed-source applications due to LGPL licensing. Kivy excels for touch/mobile, wxPython for native look-and-feel.
- **Architecture Consensus (High)**: Hexagonal architecture with MVVM/MVP presentation patterns provides optimal separation of concerns, enabling testability and platform independence. Domain logic lives in the core hexagon, UI and REST adapters in outer layers.
- **TDD for GUI (Medium)**: pytest-qt enables headless GUI testing with qtbot fixture. The Humble Object pattern separates testable logic from UI framework dependencies. Full UI automation is possible but slow; prefer testing business logic independently.
- **BDD Integration (Medium)**: pytest-bdd enables Gherkin scenarios for GUI acceptance tests. Requires additional setup for UI interactions but reuses pytest fixtures. Best for user-facing acceptance criteria, not low-level widget testing.
- **REST Client Patterns (High)**: httpx is the modern Python HTTP client, supporting both sync and async with HTTP/2, connection pooling, and configurable retries. Use Client instances (not top-level functions) for connection pooling benefits.
- **DevSecOps (High)**: Bandit (SAST), Safety/pip-audit (SCA), and OWASP Dependency-Check are standard for Python security scanning. Integrate into pre-commit hooks and CI/CD pipelines for shift-left security.
- **Deployment (Medium)**: PyInstaller is most mature for freezing Python GUIs to executables. tufup (based on TUF security framework) recommended for auto-updates. No cross-compilation support - build on target OS.
- **Key Risk**: Threading anti-patterns. Qt GUIs require all widget updates on main thread. Use QThread with signals/slots for background work, never update UI directly from worker threads.

## Key Principles

### 1. Design for Feedback (Fast Feedback Loops)
**Consensus: High**

Dave Farley's continuous delivery principles emphasize creating "fast, efficient, high-quality feedback loops that operate from the few seconds of feedback from a TDD test run, to the feedback generated by creating a releasable thing multiple times per day" ([Continuous Delivery Blog](https://www.davefarley.net/?p=305)). For GUI applications, this means:

- **Commit stage**: Fast unit tests (<10s) for business logic, coding standards, type checking
- **Acceptance stage**: BDD-style acceptance tests against deployed application checking user requirements
- **Production readiness**: Cannot release if any test fails, driving deterministic, repeatable tests

Evidence: Farley's "Continuous Delivery" book (co-authored with Jez Humble) and training materials establish this as core CD practice ([Continuous Delivery Training](https://www.continuous-delivery.co.uk/)). The deployment pipeline pattern is widely adopted in industry.

**Application to GUI**: Separate UI from logic using hexagonal architecture so business rules can be tested in milliseconds without launching GUI framework. Reserve slow GUI tests for acceptance criteria only.

### 2. Separate Concerns (Hexagonal Architecture + Presentation Patterns)
**Consensus: High**

Alistair Cockburn's hexagonal architecture (ports and adapters) provides the foundational principle: "Allow an application to equally be driven by users, programs, automated test or batch scripts, and to be developed and tested in isolation from its eventual run-time devices and databases" ([Hexagonal Architecture](https://alistaircockburn.com/Hexagonal%20Budapest%2023-05-18.pdf)).

**Structure**:
- **Inner hexagon (domain)**: Pure business logic, no external dependencies
- **Ports**: Interfaces defining how domain interacts with outside world (primary ports = inbound, secondary ports = outbound)
- **Adapters**: Implementations that connect ports to specific technologies (GUI adapter, REST adapter, database adapter)

**Presentation layer patterns** (MVC, MVP, MVVM) complement hexagonal architecture by organizing the UI adapter:

- **MVP (Model-View-Presenter)**: Presenter receives input from view, calls domain model, returns results to view. View is passive ([Martin Fowler - GUI Architectures](https://martinfowler.com/eaaDev/uiArchs.html)).
- **MVVM (Model-View-ViewModel)**: ViewModel is presentation model containing all UI state/behavior without UI controls. View binds to ViewModel. Popularized by Microsoft for WPF/Silverlight ([MVVM Wikipedia](https://en.wikipedia.org/wiki/Model–view–viewmodel)).

Evidence: Fowler notes "the best way to think of MVC is as a set of principles including the separation of presentation from domain logic and synchronizing presentation state through events" ([GUI Architectures](https://martinfowler.com/eaaDev/uiArchs.html)). Combining hexagonal with MVVM: domain in inner hexagon, ViewModel in adapter layer, View as UI-specific binding ([Hexagonal + MVVM](https://medium.com/@Marchosiax/android-modularization-hexagonal-architecture-with-kotlin-and-mvvm-part-1-db338833d6c2)).

**Why not traditional MVC for complex apps?** MVC can lead to "code where business logic is intertwined with presentation logic." Hexagonal architecture "promotes a clearer isolation" and works better as complexity grows ([Hexagonal vs MVC](https://scalastic.io/en/hexagonal-architecture/)).

### 3. Work in Small, Reversible Increments (TDD Red-Green-Refactor)
**Consensus: High**

Kent Beck's TDD cycle from "Test Driven Development by Example":
1. **Red**: Write a failing test for the next small behavior
2. **Green**: Make it pass quickly, "committing whatever sins necessary"
3. **Refactor**: Clean up duplication and code smells

"The most common way to screw up TDD is neglecting the third step" ([Red-Green-Refactor](https://medium.com/@melvinzehl/red-green-refactor-dd1d0abd3e16)). The principle is "make it run, then make it right" ([TDD by Example Notes](https://stanislaw.github.io/2016-01-25-notes-on-test-driven-development-by-example-by-kent-beck.html)).

**Pattern catalog** from Beck's book:
- **One Step Test**: Pick a test that teaches something and you're confident implementing
- **Fake It**: Return hardcoded values, then gradually replace with real logic
- **Triangulate**: Add multiple test cases to force generalization
- **Obvious Implementation**: If you know what to type, type it; if unsure, fake it first

Evidence: Beck developed TDD in late 1990s as part of Extreme Programming. He created the first xUnit framework (SUnit for Smalltalk) ([TDD Wikipedia](https://en.wikipedia.org/wiki/Test-driven_development)). TDD is foundational to agile practices and modern software engineering ([Martin Fowler - TDD](https://martinfowler.com/bliki/TestDrivenDevelopment.html)).

### 4. Make Behavior Explicit (BDD and Gherkin)
**Consensus: Medium**

Behavior-Driven Development "allows teams to align what they build with what users actually need" ([BDD with Gherkin](https://testsigma.com/blog/behavior-driven-development-bdd-with-gherkin/)). pytest-bdd bridges "business-readable Gherkin scenarios with executable Python tests" and "enables unifying unit and functional tests" ([pytest-bdd Guide](https://pytest-with-eric.com/bdd/pytest-bdd/)).

**Gherkin syntax**:
```gherkin
Feature: User Login
  Scenario: Successful login with valid credentials
    Given the user is on the login page
    When the user enters valid username and password
    And clicks the login button
    Then the user should see the dashboard
```

**Project structure**:
```
features/          # .feature files with Gherkin scenarios
tests/
  step_defs/       # Python step definitions matching Gherkin steps
conftest.py        # Shared fixtures
```

Evidence: pytest-bdd "benefits from the power and flexibility of pytest" and "allows the reuse of test setups" ([pytest-bdd PyPI](https://pypi.org/project/pytest-bdd/)). BDD originated with Dan North as evolution of TDD to focus on behavior rather than tests.

**Medium consensus** because: BDD adds ceremony and requires stakeholder engagement. For small teams or internal tools, TDD alone may suffice. BDD shines when business stakeholders can write/review Gherkin scenarios.

### 5. Optimize for Change (SOLID Principles)
**Consensus: High**

Robert C. Martin (Uncle Bob) established SOLID as core OOP principles, though he notes they "are general programming principles that could be used regardless of the paradigm" ([Uncle Bob on SOLID](https://en.wikipedia.org/wiki/Robert_C._Martin)):

- **S - Single Responsibility Principle (SRP)**: A class should have one reason to change. Split responsibilities so changes affect isolated modules.
- **O - Open/Closed Principle (OCP)**: Open for extension, closed for modification. Add behavior with new code, not by altering existing code.
- **L - Liskov Substitution Principle (LSP)**: Subtypes must be substitutable for base types without breaking behavior.
- **I - Interface Segregation Principle (ISP)**: Clients shouldn't depend on interfaces they don't use. Prefer small, focused interfaces.
- **D - Dependency Inversion Principle (DIP)**: High-level modules shouldn't depend on low-level modules. Both should depend on abstractions. "Inversion of typical control flow where UI depends on abstract domain logic, and domain logic depends on database. DIP states both UI and database should depend on domain logic" ([Clean Architecture](https://cleancoders.com/episode/clean-code-episode-65)).

Evidence: Martin authored "Clean Code" (2008), co-authored Agile Manifesto, and created the SOLID acronym ([Robert C. Martin](https://en.wikipedia.org/wiki/Robert_C._Martin)). SOLID is taught in CS curricula and widely referenced in software engineering literature.

### 6. Minimize Untestable Code (Humble Object Pattern)
**Consensus: High**

The Humble Object pattern "helps in separating the complex or hard-to-test parts of a system from the simpler and more testable parts" ([Humble Object Pattern](https://maxim-gorin.medium.com/cleaner-code-better-tests-leveraging-humble-objects-for-better-architecture-134d30d70b2f)). Origin: Michael Feathers coined "humble" in context of testing; Gerard Meszaros formalized in "xUnit Test Patterns" ([Humble Object](http://xunitpatterns.com/Humble%20Object.html)).

**For GUI applications**: "UI testing is hard because the framework usually creates the UI objects for us, and we only fill in the blanks" ([Humble Object in Swift](https://medium.com/ios-os-x-development/humble-object-pattern-in-swift-de5efe8fe05a)). Solution:

1. **View (humble object)**: Handles UI controls, display, input capture. Zero business logic.
2. **Presenter/ViewModel (testable)**: Processes data, formatting, business rules. No UI framework dependencies.

"We extract the logic into a separate easy-to-test component that is decoupled from its environment" ([Humble Object](https://steven-giesel.com/blogPost/47acad0a-255c-489b-a805-d0f46bde23e5/the-humble-object-pattern)).

Evidence: Fowler recommends "ensuring these controls have the absolute minimum of behavior, using patterns like Presentation Model (MVVM) and Passive View" ([Martin Fowler - Humble Object](https://martinfowler.com/bliki/HumbleObject.html)). This aligns with MVP/MVVM patterns and hexagonal architecture.

### 7. Continuously Refactor (Technical Debt Management)
**Consensus: High**

"Clean Code isn't just code that runs. It's a professional discipline focused on clarity, simplicity, and long-term maintainability" ([Clean Code Guy](https://cleancodeguy.com/blog/robert-martin-uncle-bob)). Refactoring is third step of red-green-refactor cycle.

Michael Feathers' "Working Effectively with Legacy Code" addresses the testing paradox: "Before you change code, you should have tests in place. But to put tests in place, you have to change code" ([Legacy Code Key Points](https://understandlegacycode.com/blog/key-points-of-working-effectively-with-legacy-code/)).

**Seam model**: "A place where you can alter behavior in your program without editing in that place" ([Working with Legacy Code](https://gist.github.com/jeremy-w/6774525)). Types:
- **Object seams** (preferred): Define interfaces, replace with mocks/fakes in tests
- **Link seams**: Replace implementation at link time
- **Preprocessing seams**: Use macros (C/C++ specific)

**Legacy Code Change Algorithm**:
1. Identify change points
2. Find test points (where behavior can be sensed)
3. Break dependencies (carefully) to get code into test harness
4. Cover with characterization tests
5. Add new functionality via TDD
6. Refactor to remove duplication

Evidence: Feathers' book (2004) is seminal work on testing legacy code ([Working Effectively with Legacy Code](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052)). Uncle Bob's Clean Code emphasizes "every year, countless hours and significant resources are lost because of poorly written code" ([Clean Code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)).

## Framework Comparison

| Framework | License | Cross-Platform | Maturity | Strengths | Weaknesses | Consensus |
|-----------|---------|----------------|----------|-----------|------------|-----------|
| **PySide6** | LGPL | Windows, macOS, Linux, Android | High | Qt ecosystem, QtDesigner, commercial-friendly license, comprehensive widgets | Large app size, learning curve | **High** - Recommended for commercial apps |
| **PyQt6** | GPL or Commercial | Windows, macOS, Linux | High | Same Qt ecosystem as PySide, slightly more features | GPL requires open-source or paid license | **High** - Use for GPL projects or buy license |
| **Kivy** | MIT | Windows, macOS, Linux, iOS, Android, Raspberry Pi | Medium | Multi-touch, mobile-first, modern designs, OpenGL ES 2 | Smaller widget set, non-native look, large packages | **Medium** - Best for touch/mobile |
| **wxPython** | wxWindows (LGPL-like) | Windows, macOS, Linux | High | Native OS look-and-feel, comprehensive widgets | Active API changes, complex setup, documentation gaps | **Medium** - Use for native feel |
| **Tkinter** | Python Standard Library | All platforms | High | Built-in, simple, good for learning | Basic widgets, dated appearance | **Low** - Simple internal tools only |
| **Dear PyGui** | MIT | Windows, macOS, Linux | Medium | GPU-accelerated (OpenGL), fast for dashboards/visualization | Immediate-mode API (different paradigm), not for traditional apps | **Low** - Specialized use cases |
| **BeeWare Toga** | BSD | Windows, macOS, Linux, iOS, Android, web | Low | True native widgets per platform, Python-native | Immature, limited production use | **Low** - Experiments only |
| **Flet** | Apache 2.0 | Windows, macOS, Linux, web, mobile | Low | Modern UI, Flutter-based | Young ecosystem, less mature | **Low** - Emerging option |

**Sources**:
- [Python GUI Frameworks 2025](https://www.pythonguis.com/faq/which-python-gui-library/)
- [PyQt vs PySide Licensing](https://www.pythonguis.com/faq/pyqt-vs-pyside/)
- [Comparing Python GUI Frameworks](https://blog.logrocket.com/comparing-top-python-gui-frameworks/)
- [BeeWare Toga](https://github.com/beeware/toga)
- [Dear PyGui Libraries](https://blog.stackademic.com/9-python-libraries-i-use-for-building-guis-e9714464ef45)

### Licensing Implications

**Critical Decision Point**: PyQt vs PySide for Qt-based development.

**PyQt Licensing**:
- GPL v3 (free) or Commercial License (paid)
- "If your license is incompatible with the GPL then you need a commercial PyQt license" ([Riverbank License FAQ](https://riverbankcomputing.com/commercial/license-faq))
- Can sell GPL software but "GPL requires you to share your source code with people who buy it" ([PyQt vs PySide](https://www.pythonguis.com/faq/pyqt-vs-pyside/))

**PySide Licensing**:
- LGPL (free) or Commercial License (paid from The Qt Company)
- "LGPL does not require you to share the source code of your own applications, even if they are bundled with PySide" ([PySide Licensing](https://charleswan111.medium.com/pyqt-vs-pyside-a-comprehensive-comparison-for-python-qt-development-4f525f879cc4))
- Must allow users to replace PySide library (dynamic linking requirement)

**Recommendation (High Consensus)**: "For proprietary/commercial closed-source applications without a budget for commercial licenses, PySide (LGPL) is generally the recommended choice" ([PyQt vs PySide](https://www.pythonguis.com/faq/pyqt-vs-pyside/)).

## Architecture Patterns (Hexagonal Applied to GUI)

### Layer Structure

```
┌─────────────────────────────────────────────────────────┐
│                     Adapters (Outer)                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │  GUI Adapter │  │ REST Adapter │  │   DB Adapter │  │
│  │  (Qt View)   │  │   (httpx)    │  │  (SQLAlchemy)│  │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  │
│         │                  │                  │          │
│  ┌──────▼──────────────────▼──────────────────▼───────┐ │
│  │              Ports (Interfaces)                     │ │
│  │  • IUserInterface  • IApiClient  • IRepository     │ │
│  └──────────────────────┬───────────────────────────── ┘ │
│                         │                                │
│              ┌──────────▼──────────┐                     │
│              │  Domain (Inner)     │                     │
│              │  • Business Logic   │                     │
│              │  • Domain Models    │                     │
│              │  • Use Cases        │                     │
│              └─────────────────────┘                     │
└─────────────────────────────────────────────────────────┘
```

### Concrete Python Example (PySide6 + httpx + hexagonal)

**Domain Layer** (`src/domain/`):
```python
# domain/models.py
from dataclasses import dataclass

@dataclass
class User:
    id: int
    name: str
    email: str

# domain/ports.py
from abc import ABC, abstractmethod
from typing import List

class IUserRepository(ABC):
    """Secondary port - outbound"""
    @abstractmethod
    async def get_users(self) -> List[User]:
        pass

class IUserInterface(ABC):
    """Primary port - inbound"""
    @abstractmethod
    def display_users(self, users: List[User]) -> None:
        pass

    @abstractmethod
    def show_error(self, message: str) -> None:
        pass

# domain/use_cases.py
class FetchUsersUseCase:
    """Pure business logic - no external dependencies"""
    def __init__(self, repository: IUserRepository):
        self._repository = repository

    async def execute(self) -> List[User]:
        users = await self._repository.get_users()
        # Business rules here (filtering, validation, etc.)
        return [u for u in users if u.email]  # Example: only users with email
```

**Infrastructure Layer** (`src/infrastructure/`):
```python
# infrastructure/rest_adapter.py
import httpx
from typing import List
from domain.models import User
from domain.ports import IUserRepository

class HttpxUserRepository(IUserRepository):
    """REST adapter - implements secondary port"""
    def __init__(self, base_url: str, client: httpx.AsyncClient):
        self._base_url = base_url
        self._client = client

    async def get_users(self) -> List[User]:
        response = await self._client.get(f"{self._base_url}/users")
        response.raise_for_status()
        data = response.json()
        return [User(**item) for item in data]
```

**Presentation Layer** (`src/presentation/`):
```python
# presentation/view_model.py
from typing import List, Callable
from domain.models import User
from domain.use_cases import FetchUsersUseCase

class UserListViewModel:
    """Testable presentation logic - no Qt dependencies"""
    def __init__(self, use_case: FetchUsersUseCase):
        self._use_case = use_case
        self._on_users_loaded: Callable[[List[str]], None] | None = None
        self._on_error: Callable[[str], None] | None = None

    def bind_users_loaded(self, callback: Callable[[List[str]], None]):
        self._on_users_loaded = callback

    def bind_error(self, callback: Callable[[str], None]):
        self._on_error = callback

    async def load_users(self):
        try:
            users = await self._use_case.execute()
            user_names = [f"{u.name} ({u.email})" for u in users]
            if self._on_users_loaded:
                self._on_users_loaded(user_names)
        except Exception as e:
            if self._on_error:
                self._on_error(str(e))

# presentation/qt_view.py
from PySide6.QtWidgets import QMainWindow, QListWidget, QPushButton, QVBoxLayout, QWidget
from PySide6.QtCore import Slot
from domain.ports import IUserInterface
from presentation.view_model import UserListViewModel

class UserListWindow(QMainWindow, IUserInterface):
    """Qt-specific view - humble object with minimal logic"""
    def __init__(self, view_model: UserListViewModel):
        super().__init__()
        self._view_model = view_model
        self._view_model.bind_users_loaded(self.display_users)
        self._view_model.bind_error(self.show_error)

        self._setup_ui()

    def _setup_ui(self):
        self.setWindowTitle("User List")

        central_widget = QWidget()
        layout = QVBoxLayout()

        self.user_list = QListWidget()
        self.load_button = QPushButton("Load Users")
        self.load_button.clicked.connect(self._on_load_clicked)

        layout.addWidget(self.user_list)
        layout.addWidget(self.load_button)
        central_widget.setLayout(layout)
        self.setCentralWidget(central_widget)

    @Slot()
    def _on_load_clicked(self):
        # Delegate to view model
        import asyncio
        asyncio.create_task(self._view_model.load_users())

    def display_users(self, user_names: List[str]) -> None:
        """Implementation of IUserInterface port"""
        self.user_list.clear()
        self.user_list.addItems(user_names)

    def show_error(self, message: str) -> None:
        """Implementation of IUserInterface port"""
        from PySide6.QtWidgets import QMessageBox
        QMessageBox.critical(self, "Error", message)
```

**Application Wiring** (`src/main.py`):
```python
# main.py
import sys
import asyncio
from PySide6.QtWidgets import QApplication
import httpx

from domain.use_cases import FetchUsersUseCase
from infrastructure.rest_adapter import HttpxUserRepository
from presentation.view_model import UserListViewModel
from presentation.qt_view import UserListWindow

async def main():
    app = QApplication(sys.argv)

    # Dependency injection - wire adapters to ports
    async with httpx.AsyncClient(timeout=10.0) as client:
        repository = HttpxUserRepository("https://api.example.com", client)
        use_case = FetchUsersUseCase(repository)
        view_model = UserListViewModel(use_case)
        window = UserListWindow(view_model)

        window.show()
        sys.exit(app.exec())

if __name__ == "__main__":
    asyncio.run(main())
```

**Why This Architecture?**

1. **Domain layer is pure Python**: Test without Qt or httpx installed
2. **Ports define contracts**: Swap REST for GraphQL/gRPC without touching domain
3. **ViewModel is testable**: No Qt imports, can test with simple callbacks
4. **View is humble**: Minimal logic, delegates to ViewModel
5. **Dependency Inversion**: High-level use cases don't depend on low-level HTTP/GUI frameworks

**Sources**:
- [Hexagonal Architecture](https://alistaircockburn.com/Hexagonal%20Budapest%2023-05-18.pdf)
- [Hexagonal + MVVM](https://medium.com/@Marchosiax/android-modularization-hexagonal-architecture-with-kotlin-and-mvvm-part-1-db338833d6c2)
- [Martin Fowler - Presentation Model](https://martinfowler.com/eaaDev/PresentationModel.html)

## TDD for GUI Applications

### Testing Strategy Pyramid

```
        ┌──────────────┐
        │  E2E GUI     │  Slow, brittle, high-level
        │  (pytest-qt) │  ~5-10% of tests
        ├──────────────┤
        │ Integration  │  Medium speed, verify adapter wiring
        │ (pytest)     │  ~20-30% of tests
        ├──────────────┤
        │   Unit       │  Fast, domain + ViewModel logic
        │  (pytest)    │  ~60-75% of tests
        └──────────────┘
```

### Unit Testing (Domain + ViewModel)

**Test the domain** - pure Python, no mocks needed:

```python
# tests/domain/test_use_cases.py
import pytest
from domain.models import User
from domain.use_cases import FetchUsersUseCase
from domain.ports import IUserRepository

class FakeUserRepository(IUserRepository):
    """Test double - no external dependencies"""
    def __init__(self, users: list[User]):
        self._users = users

    async def get_users(self) -> list[User]:
        return self._users

@pytest.mark.asyncio
async def test_fetch_users_filters_users_without_email():
    # Arrange
    users = [
        User(id=1, name="Alice", email="alice@example.com"),
        User(id=2, name="Bob", email=""),  # No email
        User(id=3, name="Charlie", email="charlie@example.com"),
    ]
    repository = FakeUserRepository(users)
    use_case = FetchUsersUseCase(repository)

    # Act
    result = await use_case.execute()

    # Assert
    assert len(result) == 2
    assert all(u.email for u in result)
    assert result[0].name == "Alice"
    assert result[1].name == "Charlie"
```

**Test the ViewModel** - no Qt, simple callbacks:

```python
# tests/presentation/test_view_model.py
import pytest
from presentation.view_model import UserListViewModel
from domain.use_cases import FetchUsersUseCase
from tests.domain.test_use_cases import FakeUserRepository
from domain.models import User

@pytest.mark.asyncio
async def test_view_model_loads_users_and_triggers_callback():
    # Arrange
    users = [User(id=1, name="Alice", email="alice@example.com")]
    repository = FakeUserRepository(users)
    use_case = FetchUsersUseCase(repository)
    view_model = UserListViewModel(use_case)

    loaded_users = []
    view_model.bind_users_loaded(lambda users: loaded_users.extend(users))

    # Act
    await view_model.load_users()

    # Assert
    assert len(loaded_users) == 1
    assert "Alice" in loaded_users[0]
    assert "alice@example.com" in loaded_users[0]

@pytest.mark.asyncio
async def test_view_model_handles_errors():
    # Arrange
    class ErrorRepository(IUserRepository):
        async def get_users(self):
            raise ValueError("Network error")

    repository = ErrorRepository()
    use_case = FetchUsersUseCase(repository)
    view_model = UserListViewModel(use_case)

    errors = []
    view_model.bind_error(lambda msg: errors.append(msg))

    # Act
    await view_model.load_users()

    # Assert
    assert len(errors) == 1
    assert "Network error" in errors[0]
```

### Integration Testing (REST Adapter)

**Test REST adapter with httpx**:

```python
# tests/infrastructure/test_rest_adapter.py
import pytest
import httpx
import respx
from infrastructure.rest_adapter import HttpxUserRepository
from domain.models import User

@pytest.mark.asyncio
@respx.mock
async def test_httpx_repository_fetches_users():
    # Arrange
    mock_data = [
        {"id": 1, "name": "Alice", "email": "alice@example.com"},
        {"id": 2, "name": "Bob", "email": "bob@example.com"},
    ]
    respx.get("https://api.example.com/users").mock(return_value=httpx.Response(200, json=mock_data))

    async with httpx.AsyncClient() as client:
        repository = HttpxUserRepository("https://api.example.com", client)

        # Act
        users = await repository.get_users()

        # Assert
        assert len(users) == 2
        assert users[0].name == "Alice"
        assert users[1].name == "Bob"

@pytest.mark.asyncio
@respx.mock
async def test_httpx_repository_raises_on_http_error():
    # Arrange
    respx.get("https://api.example.com/users").mock(return_value=httpx.Response(500))

    async with httpx.AsyncClient() as client:
        repository = HttpxUserRepository("https://api.example.com", client)

        # Act & Assert
        with pytest.raises(httpx.HTTPStatusError):
            await repository.get_users()
```

**Tool**: Use `respx` library to mock httpx requests ([respx on PyPI](https://pypi.org/project/respx/)).

### GUI Testing (pytest-qt)

**pytest-qt** enables "headless testing of GUI applications" without rendering windows ([pytest-qt intro](https://pytest-qt.readthedocs.io/en/latest/intro.html)). Key features:

- **qtbot fixture**: Simulates user interactions (clicks, key presses)
- **Automatic qApp creation**: Handles Qt application lifecycle
- **Signal/slot testing**: `waitSignal()` blocks until signal emitted
- **Headless execution**: Works in CI without X server (use `pytest-xvfb` on Linux)

```python
# tests/presentation/test_qt_view.py
import pytest
from PySide6.QtCore import Qt
from presentation.qt_view import UserListWindow
from presentation.view_model import UserListViewModel
from domain.use_cases import FetchUsersUseCase
from tests.domain.test_use_cases import FakeUserRepository
from domain.models import User

@pytest.fixture
def user_window(qtbot):
    """Fixture creates window and registers with qtbot for cleanup"""
    users = [User(id=1, name="Alice", email="alice@example.com")]
    repository = FakeUserRepository(users)
    use_case = FetchUsersUseCase(repository)
    view_model = UserListViewModel(use_case)
    window = UserListWindow(view_model)

    qtbot.addWidget(window)  # Ensures proper cleanup
    return window

def test_window_displays_loaded_users(qtbot, user_window):
    # Act
    qtbot.mouseClick(user_window.load_button, Qt.LeftButton)

    # Wait for async operation (in real code, use proper signal)
    qtbot.wait(100)

    # Assert
    assert user_window.user_list.count() == 1
    assert "Alice" in user_window.user_list.item(0).text()

def test_window_shows_error_dialog(qtbot, monkeypatch):
    # Arrange
    class ErrorRepository(IUserRepository):
        async def get_users(self):
            raise ValueError("Network error")

    repository = ErrorRepository()
    use_case = FetchUsersUseCase(repository)
    view_model = UserListViewModel(use_case)
    window = UserListWindow(view_model)
    qtbot.addWidget(window)

    # Mock QMessageBox to avoid blocking
    from PySide6.QtWidgets import QMessageBox
    shown_messages = []
    monkeypatch.setattr(QMessageBox, "critical", lambda *args: shown_messages.append(args))

    # Act
    qtbot.mouseClick(window.load_button, Qt.LeftButton)
    qtbot.wait(100)

    # Assert
    assert len(shown_messages) == 1
    assert "Network error" in shown_messages[0][2]
```

**Best Practices**:
- Use `qtbot.addWidget()` to register widgets for cleanup
- Use `qtbot.wait()` or `waitSignal()` for async operations
- Mock blocking dialogs (QMessageBox, QInputDialog) to avoid test hangs
- Keep GUI tests to acceptance criteria only - most logic tested in unit tests

**Sources**:
- [pytest-qt Documentation](https://pytest-qt.readthedocs.io/en/latest/intro.html)
- [Headless PyQt Testing](https://ilmanzo.github.io/post/testing_pyside_gui_applications/)
- [pytest-qt on PyPI](https://pypi.org/project/pytest-qt/)

### Testing Anti-Pattern: Blocking the GUI Thread

**Problem**: "By default, any execution triggered by the event loop will also run synchronously within this thread. In practice, this means that the time your PyQt application spends doing something, the communication with the window and the interaction with the GUI are frozen" ([Multithreading PyQt](https://www.pythonguis.com/tutorials/multithreading-pyqt-applications-qthreadpool/)).

**Solution**: Use QThread with signals/slots for background work. Never update GUI from worker thread - emit signal instead.

## BDD for GUI Applications

### Feature File Example

```gherkin
# features/user_management.feature
Feature: User Management
  As a system administrator
  I want to view and manage users
  So that I can maintain the user database

  Scenario: View list of users
    Given the application is running
    And the API returns the following users:
      | name    | email              |
      | Alice   | alice@example.com  |
      | Bob     | bob@example.com    |
    When I click the "Load Users" button
    Then I should see 2 users in the list
    And I should see "Alice (alice@example.com)" in the user list

  Scenario: Handle API error gracefully
    Given the application is running
    And the API is unavailable
    When I click the "Load Users" button
    Then I should see an error message containing "Network error"
```

### Step Definitions with pytest-bdd

```python
# tests/step_defs/test_user_management.py
import pytest
from pytest_bdd import scenarios, given, when, then, parsers
from PySide6.QtCore import Qt
import httpx
import respx

from presentation.qt_view import UserListWindow
from presentation.view_model import UserListViewModel
from domain.use_cases import FetchUsersUseCase
from infrastructure.rest_adapter import HttpxUserRepository

# Load scenarios from feature file
scenarios('../features/user_management.feature')

@pytest.fixture
def app_window(qtbot):
    """Create application window for scenarios"""
    async with httpx.AsyncClient() as client:
        repository = HttpxUserRepository("https://api.example.com", client)
        use_case = FetchUsersUseCase(repository)
        view_model = UserListViewModel(use_case)
        window = UserListWindow(view_model)
        qtbot.addWidget(window)
        return window

@given("the application is running")
def application_running(app_window):
    app_window.show()
    assert app_window.isVisible()

@given(parsers.parse("the API returns the following users:\n{users_table}"), target_fixture="mock_api_users")
@respx.mock
def api_returns_users(users_table):
    # Parse table from Gherkin
    lines = users_table.strip().split('\n')[1:]  # Skip header
    users = []
    for line in lines:
        parts = [p.strip() for p in line.split('|')[1:-1]]
        users.append({"id": len(users)+1, "name": parts[0], "email": parts[1]})

    respx.get("https://api.example.com/users").mock(return_value=httpx.Response(200, json=users))
    return users

@given("the API is unavailable")
@respx.mock
def api_unavailable():
    respx.get("https://api.example.com/users").mock(return_value=httpx.Response(500))

@when(parsers.parse('I click the "{button_text}" button'))
def click_button(qtbot, app_window, button_text):
    # Find button by text
    button = app_window.findChild(QPushButton, lambda w: w.text() == button_text)
    qtbot.mouseClick(button, Qt.LeftButton)
    qtbot.wait(100)  # Wait for async operation

@then(parsers.parse("I should see {count:d} users in the list"))
def verify_user_count(app_window, count):
    assert app_window.user_list.count() == count

@then(parsers.parse('I should see "{text}" in the user list'))
def verify_user_in_list(app_window, text):
    items = [app_window.user_list.item(i).text() for i in range(app_window.user_list.count())]
    assert any(text in item for item in items)

@then(parsers.parse('I should see an error message containing "{text}"'))
def verify_error_message(monkeypatch, text):
    # This would need to capture the QMessageBox shown
    # Simplified for example
    pass
```

**Project Structure**:
```
tests/
  features/
    user_management.feature
    api_integration.feature
  step_defs/
    test_user_management.py
    test_api_integration.py
  conftest.py              # Shared fixtures
```

**Strengths of BDD for GUI**:
- Executable specifications readable by non-technical stakeholders
- Forces focus on user behavior, not implementation
- Reusable step definitions across scenarios
- Works with pytest fixtures and plugins

**Weaknesses**:
- More ceremony than pure pytest
- Requires discipline to keep steps generic and reusable
- Can be overkill for small teams or internal tools
- Gherkin parsing adds small performance overhead

**Consensus: Medium** - BDD shines when business stakeholders write/review scenarios. For developer-only teams, TDD with descriptive test names may suffice.

**Sources**:
- [pytest-bdd Guide](https://pytest-with-eric.com/bdd/pytest-bdd/)
- [BDD with Gherkin](https://testsigma.com/blog/behavior-driven-development-bdd-with-gherkin/)
- [pytest-bdd PyPI](https://pypi.org/project/pytest-bdd/)

## REST API Client Patterns

### Library Comparison

| Feature | requests | httpx | aiohttp |
|---------|----------|-------|---------|
| **Sync API** | ✅ Yes | ✅ Yes | ❌ No |
| **Async API** | ❌ No | ✅ Yes | ✅ Yes |
| **HTTP/2** | ❌ No | ✅ Yes | ❌ No |
| **Connection Pooling** | ✅ Session | ✅ Client | ✅ ClientSession |
| **Type Annotations** | ❌ No | ✅ Yes | Partial |
| **Retry Support** | Via urllib3 | Via transport | Via aiohttp-retry |
| **Maturity** | High (2011) | Medium (2019) | High (2014) |
| **Consensus** | High (simple) | **High (modern)** | High (async only) |

**Recommendation (High Consensus)**: "HTTPX is the modern choice - it combines the best of both worlds with sync and async support, HTTP/2, and type hints" ([httpx vs requests vs aiohttp](https://www.speakeasy.com/blog/python-http-clients-requests-vs-httpx-vs-aiohttp)).

**When to use each**:
- **requests**: Simple scripts, existing codebase, no async needed
- **httpx**: New projects, need sync+async flexibility, want HTTP/2
- **aiohttp**: High-concurrency servers, async-only architecture

### Connection Pooling (httpx)

**Why pool?** "When you make several requests to the same host, the Client will reuse the underlying TCP connection, instead of recreating one for every single request" ([httpx Clients](https://www.python-httpx.org/advanced/clients/)). Benefits:
- Reduced latency (no handshaking)
- Reduced CPU usage and round-trips
- Reduced network congestion

**Configuration**:
```python
import httpx

limits = httpx.Limits(
    max_keepalive_connections=20,  # Number of pooled connections
    max_connections=100,            # Total connection limit
    keepalive_expiry=30.0           # Seconds before idle connection closed
)

client = httpx.AsyncClient(
    limits=limits,
    timeout=10.0,
    http2=True  # Enable HTTP/2
)
```

**Critical**: "To get the most benefit from connection pooling, make sure you're not instantiating multiple client instances - for example by using `async with` inside a 'hot loop'" ([httpx Resource Limits](https://www.python-httpx.org/advanced/resource-limits/)). Instead:

```python
# GOOD - Single client instance
class UserService:
    def __init__(self, client: httpx.AsyncClient):
        self._client = client

    async def get_user(self, user_id: int):
        response = await self._client.get(f"/users/{user_id}")
        return response.json()

# BAD - Creates new client per call
async def get_user_bad(user_id: int):
    async with httpx.AsyncClient() as client:  # DON'T DO THIS IN LOOP
        response = await client.get(f"/users/{user_id}")
        return response.json()
```

### Timeout Configuration

"There are four different types of timeouts: connect, read, write, and pool" ([httpx Timeouts](https://www.python-httpx.org/advanced/timeouts/)):

- **connect**: Maximum time to establish socket connection
- **read**: Maximum time between receiving bytes
- **write**: Maximum time between sending bytes
- **pool**: Maximum time to acquire connection from pool

```python
timeout = httpx.Timeout(
    connect=5.0,   # 5 seconds to connect
    read=10.0,     # 10 seconds to read response
    write=5.0,     # 5 seconds to send request
    pool=5.0       # 5 seconds to get connection from pool
)

client = httpx.AsyncClient(timeout=timeout)

# Or use scalar for all timeouts
client = httpx.AsyncClient(timeout=10.0)

# Disable timeouts (dangerous in production!)
client = httpx.AsyncClient(timeout=None)
```

**Best Practice**: "Always set timeouts for your requests to prevent them from hanging indefinitely" ([httpx Retry Guide](https://scrapeops.io/python-web-scraping-playbook/python-httpx-retry-failed-requests/)).

### Retry Logic

**Built-in connection retries**:
```python
transport = httpx.HTTPTransport(retries=3)  # Retry on ConnectError/ConnectTimeout
client = httpx.AsyncClient(transport=transport)
```

**For broader retry logic** (HTTP errors, rate limits), use `tenacity`:

```python
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type
import httpx

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=1, max=10),
    retry=retry_if_exception_type((httpx.HTTPStatusError, httpx.ConnectError))
)
async def fetch_with_retry(client: httpx.AsyncClient, url: str):
    response = await client.get(url)
    response.raise_for_status()
    return response.json()
```

**Exponential backoff**: "Using the `backoff_factor` you can configure your script to exponentially increase the timeout between each retry (e.g., backoff_factor=1: 0.5, 1, 2, 4, 8... seconds)" ([Python Retry Guide](https://oxylabs.io/blog/python-requests-retry)).

**Best practice**: "It's better to use a smaller value for the number of retries than setting it high. This way, you can avoid indefinite retries and potential performance issues" ([httpx Retry](https://scrapeops.io/python-web-scraping-playbook/python-httpx-retry-failed-requests/)).

### Circuit Breaker Pattern

For preventing cascading failures, use circuit breaker:

```python
from tenacity import Retrying, stop_after_attempt, wait_fixed
from enum import Enum
import time

class CircuitState(Enum):
    CLOSED = "closed"    # Normal operation
    OPEN = "open"        # Failing, reject requests
    HALF_OPEN = "half_open"  # Testing if service recovered

class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout=60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failures = 0
        self.state = CircuitState.CLOSED
        self.last_failure_time = None

    async def call(self, func, *args, **kwargs):
        if self.state == CircuitState.OPEN:
            if time.time() - self.last_failure_time > self.timeout:
                self.state = CircuitState.HALF_OPEN
            else:
                raise Exception("Circuit breaker is OPEN")

        try:
            result = await func(*args, **kwargs)
            if self.state == CircuitState.HALF_OPEN:
                self.state = CircuitState.CLOSED
                self.failures = 0
            return result
        except Exception as e:
            self.failures += 1
            self.last_failure_time = time.time()
            if self.failures >= self.failure_threshold:
                self.state = CircuitState.OPEN
            raise e

# Usage
breaker = CircuitBreaker(failure_threshold=3, timeout=30)
async def fetch_users():
    async with httpx.AsyncClient() as client:
        return await breaker.call(client.get, "https://api.example.com/users")
```

**Source**: [Circuit Breaker in aiomisc](https://aiomisc.readthedocs.io/en/latest/circuit_breaker.html)

### Error Handling and User Feedback

**API Error Response Standard**: Use RFC 9457 "Problem Details for HTTP APIs" ([Error Handling Best Practices](https://www.speakeasy.com/api-design/errors)):

```json
{
  "type": "https://example.com/errors/validation-error",
  "title": "Validation Error",
  "status": 422,
  "detail": "Email field is required",
  "instance": "/api/users/123",
  "errors": [
    {"field": "email", "message": "Required field missing"}
  ]
}
```

**Client-side error handling**:
```python
class ApiError(Exception):
    """Base exception for API errors"""
    def __init__(self, status_code: int, message: str, detail: dict = None):
        self.status_code = status_code
        self.message = message
        self.detail = detail or {}
        super().__init__(message)

class ApiClient:
    async def get_users(self) -> List[User]:
        try:
            response = await self._client.get("/users")
            response.raise_for_status()
            return [User(**item) for item in response.json()]
        except httpx.HTTPStatusError as e:
            # Parse RFC 9457 error response
            try:
                error_data = e.response.json()
                raise ApiError(
                    status_code=e.response.status_code,
                    message=error_data.get("title", "API Error"),
                    detail=error_data
                )
            except ValueError:
                # Non-JSON error response
                raise ApiError(
                    status_code=e.response.status_code,
                    message=f"HTTP {e.response.status_code}: {e.response.text}"
                )
        except httpx.ConnectError:
            raise ApiError(0, "Cannot connect to server - check network connection")
        except httpx.TimeoutException:
            raise ApiError(0, "Request timed out - server not responding")
```

**User-friendly messages in GUI**:
```python
# presentation/view_model.py
async def load_users(self):
    try:
        users = await self._use_case.execute()
        self._on_users_loaded([f"{u.name} ({u.email})" for u in users])
    except ApiError as e:
        # Map technical errors to user-friendly messages
        if e.status_code == 0:
            message = e.message  # Already user-friendly
        elif e.status_code == 401:
            message = "Please log in to view users"
        elif e.status_code == 403:
            message = "You don't have permission to view users"
        elif e.status_code == 404:
            message = "User list not found"
        elif 500 <= e.status_code < 600:
            message = "Server error - please try again later"
        else:
            message = f"Unexpected error: {e.message}"

        self._on_error(message)
```

**Sources**:
- [httpx Official Docs](https://www.python-httpx.org/)
- [httpx vs requests vs aiohttp](https://www.speakeasy.com/blog/python-http-clients-requests-vs-httpx-vs-aiohttp)
- [Tenacity Retry Library](https://python.useinstructor.com/concepts/retrying/)
- [API Error Handling](https://www.speakeasy.com/api-design/errors)

## DevSecOps

### Shift-Left Security Tools

| Tool | Type | Purpose | Consensus |
|------|------|---------|-----------|
| **Bandit** | SAST | Python security linting | **High** |
| **Safety** | SCA | Dependency vulnerability scanning | High |
| **pip-audit** | SCA | Official PyPA dependency scanner | High |
| **OWASP Dependency-Check** | SCA | Multi-language dependency scanning | High |
| **Semgrep** | SAST | Pattern-based code analysis | Medium |
| **mypy** | Type Checking | Static type analysis (catches bugs) | High |
| **ruff** | Linting | Fast Python linter (replaces Flake8) | High |

### Bandit - Python SAST

"Bandit is an open-source SAST that helps identify security issues in Python code using predefined rules" ([Bandit SAST Tool](https://medium.com/@ataseren/appsec-toolkit-bandit-sast-tool-for-python-fefbbc72bf0e)). Part of OpenStack Security Project.

**Installation & Usage**:
```bash
pip install bandit

# Scan directory
bandit -r src/

# Generate JSON report
bandit -r src/ -f json -o bandit-report.json

# Exclude test files
bandit -r src/ --exclude src/tests/

# Fail CI on medium/high severity
bandit -r src/ -ll  # -ll = only medium and high
```

**Common issues detected**:
- Hardcoded passwords/secrets
- SQL injection vulnerabilities
- Insecure random number generation
- Insecure deserialization (pickle)
- Use of `exec()` or `eval()`
- Weak cryptographic algorithms

**Pre-commit integration**:
```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/PyCQA/bandit
    rev: '1.7.5'
    hooks:
      - id: bandit
        args: ['-ll', '--recursive', 'src/']
```

### Dependency Scanning

**Safety** (legacy, deprecated):
```bash
pip install safety
safety check --json
```

**pip-audit** (official replacement):
```bash
pip install pip-audit

# Scan installed packages
pip-audit

# Scan requirements.txt
pip-audit -r requirements.txt

# Generate JSON report
pip-audit --format json --output audit-report.json

# Fail on any vulnerability
pip-audit --strict
```

**OWASP Dependency-Check**:
```bash
# Using Docker
docker run --rm \
  -v $(pwd):/src \
  owasp/dependency-check:latest \
  --scan /src \
  --format JSON \
  --out /src/dependency-check-report.json
```

"Dependency-Check scans the dependencies for known vulnerabilities in the National Vulnerability Database (NVD)" ([DevSecOps SAST/DAST](https://dev.to/soumya14041987/uncovering-sast-dast-owasp-dependency-check-in-devsecops-family-part-2-3hee)).

### CI/CD Integration

**GitHub Actions example**:
```yaml
name: Security Scan
on: [push, pull_request]

jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          pip install poetry
          poetry install

      - name: Run Bandit
        run: poetry run bandit -r src/ -ll

      - name: Run pip-audit
        run: |
          pip install pip-audit
          pip-audit

      - name: Run mypy
        run: poetry run mypy src/

      - name: Run ruff
        run: poetry run ruff check src/
```

**Pre-commit hooks** for fast feedback:
```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/PyCQA/bandit
    rev: '1.7.5'
    hooks:
      - id: bandit
        args: ['-ll', '--skip', 'B101,B601']

  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.1.9
    hooks:
      - id: ruff
        args: [--fix, --exit-non-zero-on-fix]

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.8.0
    hooks:
      - id: mypy
        additional_dependencies: [types-all]
```

### Secure Credential Storage

**keyring library** (OS-native credential storage):

```python
import keyring

# Store credential
keyring.set_password("myapp", "api_token", "secret_token_123")

# Retrieve credential
token = keyring.get_password("myapp", "api_token")

# Delete credential
keyring.delete_password("myapp", "api_token")
```

"The keyring library provides a secure way to handle passwords and other secrets. It interfaces with the operating system's credential storage mechanisms, such as Keychain on macOS, Windows Credential Locker on Windows, and GNOME on Linux" ([Python Keyring](https://pypi.org/project/keyring/)).

**Benefits**:
- Platform-native encryption
- No plaintext secrets in code or config files
- Consistent API across Windows/macOS/Linux

**Security consideration**: "On macOS, any Python script or application can access secrets created by keyring from that same Python executable without the operating system prompting for a password" ([Keyring Security](https://medium.com/@forsytheryan/securely-storing-credentials-in-python-with-keyring-d8972c3bd25f)). For higher security, configure Keychain Access to require password.

**Alternative: Environment variables** (12-factor app):
```python
import os
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    api_base_url: str
    api_token: str

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

settings = Settings()
```

Never commit `.env` files. Use `.env.example` as template.

### Certificate Pinning (Advanced)

For high-security applications communicating with known servers:

```python
import httpx
import ssl

# Load specific certificate
ssl_context = ssl.create_default_context()
ssl_context.load_verify_locations("path/to/cert.pem")

client = httpx.AsyncClient(verify=ssl_context)
```

**Note**: Research did not find extensive Python-specific certificate pinning libraries for httpx. The `truststore` library provides advanced TLS/SSL verification for Python.

**Sources**:
- [Bandit SAST](https://medium.com/@ataseren/appsec-toolkit-bandit-sast-tool-for-python-fefbbc72bf0e)
- [DevSecOps Pipelines Python](https://medium.com/@mrugaja3ri/devsecops-pipelines-with-python-how-to-integrate-security-tools-056171b5ef62)
- [Python Keyring](https://pypi.org/project/keyring/)
- [Secure Credential Storage](https://medium.com/@forsytheryan/securely-storing-credentials-in-python-with-keyring-d8972c3bd25f)

## Cross-Platform Deployment

### Packaging Tools Comparison

| Tool | Approach | Pros | Cons | Maturity |
|------|----------|------|------|----------|
| **PyInstaller** | Bundles Python + dependencies | Easy, wide library support, one-file mode | Large binaries, slow startup | **High** - Most popular |
| **cx_Freeze** | Similar to PyInstaller | Cross-platform, simple config | No one-file mode, larger binaries | High |
| **Nuitka** | Transpiles Python→C | Faster execution, code protection | Requires C compiler, complex setup | Medium |
| **Briefcase** | BeeWare tool | Mobile support (iOS/Android), native packaging | Young, limited docs | Low |
| **PyOxidizer** | Embeds Python in Rust binary | Single binary, fast startup | Complex config, Rust dependency | Medium |

**Recommendation (High Consensus)**: "PyInstaller is generally recommended because it is more mature than other solutions. It also has many features and is easy to use" ([Python Executable Generators](https://sparxeng.com/blog/software/python-standalone-executable-generators-pyinstaller-nuitka-cx-freeze)).

### PyInstaller Usage

**Installation**:
```bash
pip install pyinstaller
```

**Basic packaging**:
```bash
# One-folder mode (default) - creates dist/myapp/ directory
pyinstaller src/main.py --name myapp

# One-file mode - creates single executable dist/myapp.exe
pyinstaller src/main.py --name myapp --onefile

# Windowed mode (no console) for GUI apps
pyinstaller src/main.py --name myapp --windowed --onefile

# Include data files
pyinstaller src/main.py --name myapp \
  --add-data "assets:assets" \
  --add-data "config.yaml:."
```

**Spec file for complex builds**:
```python
# myapp.spec
# -*- mode: python ; coding: utf-8 -*-

a = Analysis(
    ['src/main.py'],
    pathex=[],
    binaries=[],
    datas=[('assets', 'assets'), ('config.yaml', '.')],
    hiddenimports=['pydantic', 'PySide6.QtCore'],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=['tkinter'],
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='myapp',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,  # Windowed mode
    icon='assets/icon.ico',
)
```

Build with spec: `pyinstaller myapp.spec`

**Critical limitation**: "No cross compilation is supported. You will have to run and build on the OS you intended to deploy to" ([PyInstaller Cross-Platform](https://ephemeral.cx/2013/08/cross-platform-deployment-of-python-applications-with-pyinstaller/)). Must build on Windows for Windows, macOS for macOS, Linux for Linux.

### Auto-Update Mechanism

**tufup (recommended)** - based on The Update Framework (TUF):

```bash
pip install tufup
```

"Tufup was created as a replacement for PyUpdater, given the fact that PyUpdater has been archived and is no longer maintained" ([tufup GitHub](https://github.com/dennisvang/tufup)). "Python-tuf, the reference implementation for TUF (The Update Framework) takes care of security complexity. If used properly, TUF ensures a high level of security for your update system" ([tufup](https://github.com/dennisvang/tufup)).

**How it works**:
- Creates versioned archives (gzipped bundles)
- Creates patch files (binary diffs between versions)
- Uses TUF metadata for secure update verification
- Works with PyInstaller, cx_Freeze, or plain Python scripts

**Basic update flow**:
```python
# In your application
from tufup.client import Client

def check_for_updates():
    client = Client(
        app_name="myapp",
        app_install_dir=Path.home() / "myapp",
        current_version="1.0.0",
        metadata_base_url="https://updates.example.com/metadata",
        target_base_url="https://updates.example.com/targets"
    )

    if client.check_for_updates():
        print(f"Update available: {client.new_version}")
        client.download_and_apply_update()
        # Restart application
```

**Alternative: updater4pyi** (simpler but less secure):

```python
from updater4pyi import Updater

updater = Updater(
    repo_owner="myuser",
    repo_name="myapp",
    current_version="1.0.0"
)

if updater.check_for_update():
    updater.download_update()
    updater.apply_update()
```

"updater4pyi supports downloads through HTTPS with certificate verification, making the download and update process secure" ([updater4pyi PyPI](https://pypi.org/project/updater4pyi/)).

**Key challenge**: "Updating a running executable (Frozen Bundle) is tricky because the OS locks the file. You can't just overwrite yourself while running" ([Self-Updating Desktop App](https://dev.to/freerave/i-built-a-self-updating-cross-platform-desktop-app-in-python-so-you-dont-have-to-deg)). Solutions:
- Download update to temp location
- Notify user to restart
- On restart, launcher script replaces old executable

**Sources**:
- [PyInstaller vs Nuitka vs cx_Freeze](https://sparxeng.com/blog/software/python-standalone-executable-generators-pyinstaller-nuitka-cx-freeze)
- [tufup GitHub](https://github.com/dennisvang/tufup)
- [updater4pyi PyPI](https://pypi.org/project/updater4pyi/)

## Quality Gates (Execute Stage)

For the Execute stage of code domain, applications should meet these quality gates:

### 1. Test Coverage
- **Minimum**: 80% line coverage
- **Target**: 90%+ for business logic
- **Tool**: pytest-cov
- **Gate**: `pytest --cov=src --cov-report=term --cov-fail-under=80`

### 2. Type Safety
- **Standard**: All public APIs type-annotated
- **Tool**: mypy
- **Configuration**: `strict = true` in mypy.ini
- **Gate**: `mypy src/ --strict`

### 3. Security Scanning
- **SAST**: Bandit with no medium/high severity issues
- **SCA**: pip-audit with no known vulnerabilities
- **Gate**: `bandit -r src/ -ll && pip-audit --strict`

### 4. Code Quality
- **Linting**: ruff with no violations
- **Complexity**: Cyclomatic complexity ≤10 per function
- **Gate**: `ruff check src/`

### 5. GUI-Specific Gates
- **Thread Safety**: All GUI updates on main thread (manual code review)
- **Responsive UI**: Long operations (>100ms) run in background threads
- **Error Handling**: All API calls have try/except with user feedback
- **Accessibility**: Keyboard navigation for all controls (manual testing)

### 6. API Integration
- **Timeouts**: All HTTP requests have explicit timeouts
- **Retries**: Transient failures retry with exponential backoff
- **Circuit Breaker**: Cascading failures prevented (for critical services)
- **Error Mapping**: Technical errors mapped to user-friendly messages

### 7. Documentation
- **README**: Installation, usage, configuration
- **API Docs**: All public functions/classes documented
- **Architecture**: Hexagonal layers documented (domain, ports, adapters)
- **Security**: Credential storage mechanism documented

### 8. Deployment
- **Packaging**: PyInstaller spec file committed
- **Multi-platform**: Binaries built for Windows, macOS, Linux
- **Auto-update**: Update mechanism configured (if applicable)
- **Signing**: Code signing for macOS/Windows (production apps)

## Anti-Patterns

### 1. Updating GUI from Background Threads (Critical)
**Problem**: "Qt requires that all GUI objects exist in the MainThread and that access to these objects is only made from the MainThread" ([PyQt Threading](https://wiki.python.org/moin/PyQt/Threading,_Signals_and_Slots)).

**Symptom**: Crashes, segfaults, unpredictable behavior.

**Wrong**:
```python
class BadWindow(QMainWindow):
    def load_data(self):
        def worker():
            data = fetch_from_api()
            self.label.setText(data)  # WRONG - updates GUI from thread

        thread = threading.Thread(target=worker)
        thread.start()
```

**Right**:
```python
class GoodWindow(QMainWindow):
    data_loaded = Signal(str)

    def __init__(self):
        super().__init__()
        self.data_loaded.connect(self._on_data_loaded)

    def load_data(self):
        worker = Worker(fetch_from_api)
        worker.signals.result.connect(self._on_data_loaded)
        QThreadPool.globalInstance().start(worker)

    @Slot(str)
    def _on_data_loaded(self, data):
        self.label.setText(data)  # Runs on main thread
```

"Qt's signals and slots are thread safe, so you can use them to establish interthread communication" ([Real Python QThread](https://realpython.com/python-pyqt-qthread/)).

### 2. Business Logic in View Layer
**Problem**: Violates separation of concerns, makes testing impossible.

**Wrong**:
```python
class UserWindow(QMainWindow):
    def on_save_clicked(self):
        name = self.name_input.text()
        email = self.email_input.text()

        # Business logic in view - WRONG
        if not email or '@' not in email:
            QMessageBox.warning(self, "Invalid email")
            return

        # API call in view - WRONG
        response = requests.post("/users", json={"name": name, "email": email})
        if response.status_code == 201:
            QMessageBox.information(self, "User saved")
```

**Right**: Use ViewModel/Presenter pattern (see Architecture section).

### 3. Ignoring Error States
**Problem**: API calls fail silently, user sees nothing.

**Wrong**:
```python
async def load_users(self):
    try:
        users = await self._client.get("/users")
        self.display_users(users.json())
    except:
        pass  # Silent failure
```

**Right**:
```python
async def load_users(self):
    try:
        users = await self._client.get("/users")
        users.raise_for_status()
        self.display_users(users.json())
    except httpx.HTTPStatusError as e:
        self.show_error(f"Failed to load users: {e.response.status_code}")
    except httpx.ConnectError:
        self.show_error("Cannot connect to server - check network")
    except Exception as e:
        self.show_error(f"Unexpected error: {e}")
        logger.exception("Unexpected error loading users")
```

### 4. No Connection Pooling
**Problem**: Creates new HTTP client for each request, wasting resources.

**Wrong**:
```python
async def get_user(user_id: int):
    async with httpx.AsyncClient() as client:  # New connection every call
        response = await client.get(f"/users/{user_id}")
        return response.json()
```

**Right**:
```python
class UserService:
    def __init__(self, client: httpx.AsyncClient):
        self._client = client  # Shared client with connection pool

    async def get_user(self, user_id: int):
        response = await self._client.get(f"/users/{user_id}")
        return response.json()
```

### 5. Hardcoded Credentials
**Problem**: Security vulnerability, credentials in version control.

**Wrong**:
```python
API_TOKEN = "sk_live_12345abcde"  # NEVER DO THIS
client = httpx.AsyncClient(headers={"Authorization": f"Bearer {API_TOKEN}"})
```

**Right**:
```python
import keyring
import os

# Production: from keyring
token = keyring.get_password("myapp", "api_token")

# Development: from environment
if not token:
    token = os.getenv("API_TOKEN")

if not token:
    raise ValueError("API_TOKEN not configured")

client = httpx.AsyncClient(headers={"Authorization": f"Bearer {token}"})
```

### 6. No Timeout on HTTP Requests
**Problem**: Requests hang indefinitely if server unresponsive.

**Wrong**:
```python
client = httpx.AsyncClient()  # Default timeout is 5 seconds, but can be disabled
```

**Right**:
```python
client = httpx.AsyncClient(timeout=10.0)  # Explicit timeout
```

### 7. Testing Against Production API
**Problem**: Tests are slow, non-deterministic, can modify production data.

**Wrong**:
```python
async def test_get_users():
    client = httpx.AsyncClient()
    response = await client.get("https://api.production.com/users")  # REAL API
    assert response.status_code == 200
```

**Right**:
```python
@pytest.mark.asyncio
@respx.mock
async def test_get_users():
    respx.get("https://api.example.com/users").mock(
        return_value=httpx.Response(200, json=[{"id": 1, "name": "Alice"}])
    )

    async with httpx.AsyncClient() as client:
        repository = HttpxUserRepository("https://api.example.com", client)
        users = await repository.get_users()
        assert len(users) == 1
```

### 8. God Object / Monolithic Window Class
**Problem**: Single class handles UI, business logic, API calls, state management.

**Wrong**:
```python
class MassiveWindow(QMainWindow):
    def __init__(self):
        # 500 lines of UI setup
        # 200 lines of business logic
        # 100 lines of API calls
        # 50 lines of state management
```

**Right**: Separate concerns into layers (hexagonal architecture).

## Logging and Observability

### structlog for GUI Applications

"structlog is an open-source logging tool for Python known for its simple API, performance, and quality of life features" ([structlog Guide](https://betterstack.com/community/guides/logging/structlog/)). Key benefits:

- **Structured output**: JSON for production, human-readable for development
- **Context binding**: Attach context (user_id, request_id) to logger instances
- **Performance**: Minimal overhead
- **Integration**: Works with standard logging module

**Configuration**:
```python
# src/infrastructure/logging_config.py
import structlog
import sys

def configure_logging(environment: str = "development"):
    """Configure structlog for GUI application"""
    processors = [
        structlog.stdlib.add_log_level,
        structlog.stdlib.add_logger_name,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
    ]

    if environment == "production":
        # JSON for log aggregators
        processors.append(structlog.processors.JSONRenderer())
    else:
        # Human-readable for development
        processors.append(structlog.dev.ConsoleRenderer())

    structlog.configure(
        processors=processors,
        wrapper_class=structlog.stdlib.BoundLogger,
        context_class=dict,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )

# Use in application
from structlog import get_logger

logger = get_logger()

# Bind context
logger = logger.bind(user_id=123, session_id="abc")

# Log events
logger.info("user_logged_in", username="alice")
logger.error("api_call_failed", endpoint="/users", status_code=500)
```

**Best Practices**:
- "Log to unbuffered standard out and let other tools take care of the rest" ([structlog Best Practices](https://www.structlog.org/en/stable/logging-best-practices.html))
- Use JSON in production for log aggregators
- Include context (user_id, request_id) for tracing
- Log exceptions with sufficient detail for debugging

**Log Levels**:
- **DEBUG**: Detailed diagnostic info (verbose)
- **INFO**: Normal operation events (user actions, API calls)
- **WARNING**: Potential issues, degraded functionality
- **ERROR**: Operation failures (API errors, validation failures)
- **CRITICAL**: Application-wide failures

**GUI-specific logging**:
```python
# Log user actions
logger.info("button_clicked", button="load_users", user_id=current_user.id)

# Log API calls
logger.info("api_request", method="GET", endpoint="/users", timeout=10.0)

# Log errors with user-facing message
try:
    users = await api.get_users()
except ApiError as e:
    logger.error("api_error",
                 endpoint="/users",
                 status_code=e.status_code,
                 user_message=e.message)
    self.show_error(e.message)
```

**Sources**:
- [structlog Documentation](https://www.structlog.org/en/stable/)
- [structlog Best Practices](https://www.structlog.org/en/stable/logging-best-practices.html)
- [Python Logging Guide](https://signoz.io/guides/python-logging-best-practices/)

## Configuration Management

### Environment-Based Configuration

**Using pydantic-settings** (recommended):

```python
# src/domain/config.py
from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import Field

class AppSettings(BaseSettings):
    """Application configuration from environment variables"""

    # API configuration
    api_base_url: str = Field(
        default="https://api.example.com",
        description="Base URL for REST API"
    )
    api_timeout: int = Field(default=10, description="API timeout in seconds")
    api_token: str = Field(description="API authentication token")

    # Application settings
    app_name: str = Field(default="MyApp", description="Application name")
    log_level: str = Field(default="INFO", description="Logging level")
    environment: str = Field(default="development", description="Environment: development/production")

    # Feature flags
    enable_auto_update: bool = Field(default=True, description="Enable auto-update feature")
    enable_analytics: bool = Field(default=False, description="Enable analytics")

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
        extra="ignore"
    )

# Usage
settings = AppSettings()
print(f"Connecting to {settings.api_base_url}")
```

**.env file** (not committed):
```bash
# .env
API_BASE_URL=https://api.staging.com
API_TOKEN=sk_test_12345
LOG_LEVEL=DEBUG
ENVIRONMENT=development
```

**.env.example** (committed as template):
```bash
# .env.example
API_BASE_URL=https://api.example.com
API_TOKEN=your_token_here
LOG_LEVEL=INFO
ENVIRONMENT=production
```

**Benefits**:
- Type validation via Pydantic
- Environment variable override
- Default values for optional settings
- Single source of truth
- IDE autocomplete for settings

**Sources**:
- [Pydantic Settings](https://docs.pydantic.dev/latest/concepts/pydantic_settings/)
- [Dynaconf](https://github.com/dynaconf/dynaconf)
- [Python Config Best Practices](https://tech.preferred.jp/en/blog/working-with-configuration-in-python/)

## Accessibility Considerations

### WCAG Guidelines for Desktop GUIs

"The Web Content Accessibility Guidelines (WCAG) provide criteria and standards for measuring accessibility" ([WCAG Guidelines](https://www.uxpin.com/studio/blog/how-to-test-screen-reader-compatibility/)). Key principles apply to desktop GUIs:

1. **Perceivable**: Information must be presentable to users in ways they can perceive
2. **Operable**: UI components and navigation must be operable
3. **Understandable**: Information and operation must be understandable
4. **Robust**: Content must be robust enough for assistive technologies

### Keyboard Navigation

**All controls must be operable via keyboard**:
```python
# PySide6 example - set tab order
self.name_input.setTabOrder(self.email_input)
self.email_input.setTabOrder(self.save_button)

# Set keyboard shortcut
self.save_button.setShortcut("Ctrl+S")
```

### Screen Reader Support

**Python-powered screen readers**:
- **NVDA** (Windows): Written in Python, uses IAccessible2
- **Orca** (Linux): Python-based, provides speech and Braille output

**Testing**:
- JAWS (Windows, paid)
- NVDA (Windows, free)
- VoiceOver (macOS/iOS, built-in)
- Narrator (Windows, built-in)

"Different screen readers handle content in unique ways. Testing with multiple screen readers gives you a more complete understanding" ([Screen Reader Testing](https://beaccessible.com/post/screen-reader-accessibility-testing/)).

### Contrast Ratios

"WCAG recommend a minimum contrast ratio of 4.5:1 for normal text and 3:1 for large text" ([WCAG Contrast](https://www.pythoncentral.io/how-to-ensure-accessibility-in-python-web-development-a-beginners-guide/)).

**Qt styling**:
```python
# Ensure sufficient contrast
self.setStyleSheet("""
    QLabel {
        color: #000000;  /* Black text */
        background-color: #FFFFFF;  /* White background */
    }
""")
```

### Progress Indicators

"Don't rely only on color or animation to show progress. Add text elements like percentages, step counts, or time estimates" ([Progress Bars Guide](https://www.datacamp.com/tutorial/progress-bars-in-python)).

```python
# Accessible progress bar
self.progress_bar = QProgressBar()
self.progress_bar.setFormat("%p% - Loading users...")  # Text + percentage
self.progress_bar.setAccessibleName("User loading progress")
```

**Sources**:
- [Python Powered Accessibility](https://wiki.gnome.org/Accessibility/PythonPoweredAccessibility)
- [WCAG Screen Reader Guidelines](https://www.powermapper.com/tests/screen-readers/wcag/)

## Dependency Injection for Testability

**Pattern: Constructor Injection**

```python
# domain/use_cases.py
class FetchUsersUseCase:
    """Use case depends on abstraction (IUserRepository), not concrete class"""
    def __init__(self, repository: IUserRepository):
        self._repository = repository

    async def execute(self) -> List[User]:
        return await self._repository.get_users()

# tests/test_use_cases.py
def test_fetch_users():
    # Test double injected via constructor
    fake_repo = FakeUserRepository([User(id=1, name="Alice", email="alice@example.com")])
    use_case = FetchUsersUseCase(fake_repo)

    users = await use_case.execute()
    assert len(users) == 1
```

**Benefits**: "Classes no longer decide which specific implementations to use; they simply work with what they are given. This separation makes testing much easier because you can now pass in mock objects or alternative implementations" ([Python Dependency Injection](https://betterstack.com/community/guides/scaling-python/python-dependency-injection/)).

**DI vs Mocking**: "Dependency injection takes more work to set up, but it's well positioned for high-frequency usage" ([DI vs Mocking](https://betterprogramming.pub/testing-in-python-dependency-injection-vs-mocking-5e542783cb20)). Use DI for architecture, mocking for occasional test needs.

**Lightweight DI container (optional)**: For complex applications, consider `dependency-injector`:

```python
from dependency_injector import containers, providers
import httpx

class AppContainer(containers.DeclarativeContainer):
    config = providers.Configuration()

    http_client = providers.Resource(
        httpx.AsyncClient,
        timeout=config.api_timeout,
        base_url=config.api_base_url
    )

    user_repository = providers.Factory(
        HttpxUserRepository,
        client=http_client
    )

    fetch_users_use_case = providers.Factory(
        FetchUsersUseCase,
        repository=user_repository
    )

# Wire dependencies
container = AppContainer()
container.config.from_dict({
    "api_timeout": 10.0,
    "api_base_url": "https://api.example.com"
})

use_case = container.fetch_users_use_case()
```

**Sources**:
- [Python Dependency Injection](https://testdriven.io/blog/python-dependency-injection/)
- [DI vs Mocking](https://betterprogramming.pub/testing-in-python-dependency-injection-vs-mocking-5e542783cb20)
- [dependency-injector](https://python-dependency-injector.ets-labs.org/)

## Responsive UI Patterns

### Progress Indicators

**For determinate progress** (known total):
```python
from PySide6.QtWidgets import QProgressBar

self.progress_bar = QProgressBar()
self.progress_bar.setRange(0, 100)
self.progress_bar.setValue(0)

# Update in background thread via signal
@Slot(int)
def on_progress_updated(self, value: int):
    self.progress_bar.setValue(value)
```

**For indeterminate progress** (unknown total):
```python
self.progress_bar = QProgressBar()
self.progress_bar.setRange(0, 0)  # Indeterminate mode
self.progress_bar.setFormat("Loading...")
```

**Best Practice**: "Use the indeterminate mode when you don't know how to accurately measure the time that the long-running task takes to complete" ([Tkinter Progressbar](https://www.pythontutorial.net/tkinter/tkinter-progressbar/)).

### Async Operations with QThread

**Worker pattern** (recommended):
```python
from PySide6.QtCore import QObject, Signal, QThreadPool, QRunnable, Slot

class WorkerSignals(QObject):
    progress = Signal(int)
    result = Signal(object)
    error = Signal(str)
    finished = Signal()

class Worker(QRunnable):
    def __init__(self, fn, *args, **kwargs):
        super().__init__()
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignals()

    @Slot()
    def run(self):
        try:
            result = self.fn(*self.args, **self.kwargs)
            self.signals.result.emit(result)
        except Exception as e:
            self.signals.error.emit(str(e))
        finally:
            self.signals.finished.emit()

# Usage in window
def load_users(self):
    worker = Worker(fetch_users_from_api)
    worker.signals.result.connect(self.on_users_loaded)
    worker.signals.error.connect(self.on_error)
    worker.signals.finished.connect(lambda: self.progress_bar.hide())

    QThreadPool.globalInstance().start(worker)
    self.progress_bar.show()
```

**Sources**:
- [QThreadPool Tutorial](https://www.pythonguis.com/tutorials/multithreading-pyqt-applications-qthreadpool/)
- [Progress Bars in Python](https://www.datacamp.com/tutorial/progress-bars-in-python)

## Pytest Fixtures for GUI Testing

### Fixture Scopes

```python
import pytest
from PySide6.QtWidgets import QApplication

@pytest.fixture(scope="session")
def qapp():
    """Session-scoped QApplication - created once for all tests"""
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    yield app
    # Teardown runs after all tests

@pytest.fixture(scope="function")
def user_window(qtbot, qapp):
    """Function-scoped window - new instance per test"""
    window = UserListWindow()
    qtbot.addWidget(window)
    yield window
    # qtbot handles cleanup automatically

@pytest.fixture
def mock_api(respx_mock):
    """Function-scoped API mock"""
    respx_mock.get("https://api.example.com/users").mock(
        return_value=httpx.Response(200, json=[
            {"id": 1, "name": "Alice", "email": "alice@example.com"}
        ])
    )
    return respx_mock
```

**Best Practices**:
- Use `scope="session"` for expensive setup (QApplication)
- Use `scope="function"` (default) for test isolation
- Use `yield` for setup/teardown pattern
- "Keep fixtures small and focused: Each fixture should have a single, well-defined purpose" ([pytest Fixtures](https://www.krython.com/tutorial/python/test-fixtures-setup-and-teardown))

**Sources**:
- [pytest Fixtures Guide](https://docs.pytest.org/en/stable/how-to/fixtures.html)
- [pytest Setup and Teardown](https://pytest-with-eric.com/pytest-best-practices/pytest-setup-teardown/)

## References

### Books
- **"Continuous Delivery" by Jez Humble and David Farley** (2010) - Deployment pipelines, fast feedback loops
- **"Test Driven Development: By Example" by Kent Beck** (2002) - Red-green-refactor, TDD patterns
- **"Clean Code" by Robert C. Martin** (2008) - SOLID principles, code quality
- **"Working Effectively with Legacy Code" by Michael Feathers** (2004) - Seams, breaking dependencies
- **"Domain-Driven Design" by Eric Evans** (2003) - Bounded contexts, ubiquitous language
- **"Hexagonal Architecture Explained" by Alistair Cockburn and Juan Manuel Garrido de Paz** (2023) - Ports and adapters pattern
- **"xUnit Test Patterns" by Gerard Meszaros** (2007) - Humble Object pattern, test doubles

### Online Resources
- [Martin Fowler - GUI Architectures](https://martinfowler.com/eaaDev/uiArchs.html)
- [Martin Fowler - Presentation Model](https://martinfowler.com/eaaDev/PresentationModel.html)
- [Martin Fowler - Humble Object](https://martinfowler.com/bliki/HumbleObject.html)
- [Alistair Cockburn - Hexagonal Architecture](https://alistaircockburn.com/Hexagonal%20Budapest%2023-05-18.pdf)
- [Dave Farley's Blog](https://www.davefarley.net/)
- [Real Python - pytest-qt Tutorial](https://realpython.com/python-pyqt-qthread/)
- [pytest-qt Documentation](https://pytest-qt.readthedocs.io/en/latest/)
- [pytest-bdd Documentation](https://pypi.org/project/pytest-bdd/)
- [httpx Documentation](https://www.python-httpx.org/)
- [structlog Documentation](https://www.structlog.org/)

### Tools and Libraries
- **GUI Frameworks**: PySide6, PyQt6, Kivy, wxPython
- **HTTP Clients**: httpx, aiohttp, requests
- **Testing**: pytest, pytest-qt, pytest-bdd, respx
- **Security**: Bandit, pip-audit, OWASP Dependency-Check
- **Packaging**: PyInstaller, cx_Freeze, Nuitka
- **Updates**: tufup, updater4pyi
- **Logging**: structlog
- **Configuration**: pydantic-settings, dynaconf
- **Credentials**: keyring
- **DI**: dependency-injector
- **Retry Logic**: tenacity

## Summary: Key Principles with Consensus Ratings

1. **Hexagonal Architecture for GUI + API** (High)
   - Domain in inner hexagon (pure business logic)
   - Ports define contracts (IUserRepository, IUserInterface)
   - Adapters implement ports (Qt view, httpx client, database)
   - ViewModel/Presenter separates testable logic from UI framework

2. **PySide6 for Commercial GUI Development** (High)
   - LGPL license permits closed-source commercial apps
   - Mature Qt ecosystem with comprehensive widgets
   - QtDesigner for rapid UI prototyping
   - Cross-platform: Windows, macOS, Linux, Android

3. **httpx for REST API Calls** (High)
   - Both sync and async support
   - HTTP/2, connection pooling, type hints
   - Use AsyncClient instances (not top-level functions)
   - Configure timeouts, retries, connection limits

4. **Test Pyramid Strategy** (High)
   - 60-75% unit tests: Domain + ViewModel (fast, no mocks)
   - 20-30% integration tests: Adapters with test doubles
   - 5-10% GUI tests: pytest-qt for acceptance criteria
   - Keep GUI tests minimal - most logic tested independently

5. **TDD Red-Green-Refactor** (High)
   - Write failing test first
   - Make it pass quickly
   - Refactor to clean code
   - Use Humble Object pattern: minimize untestable code

6. **BDD with pytest-bdd** (Medium)
   - Gherkin scenarios for acceptance criteria
   - Reusable step definitions
   - Best when stakeholders review/write scenarios
   - Optional for small teams - TDD alone may suffice

7. **DevSecOps Shift-Left** (High)
   - Bandit (SAST), pip-audit (SCA) in pre-commit hooks
   - Run security scans in CI/CD
   - Use keyring for credential storage
   - Never commit secrets to version control

8. **SOLID Principles** (High)
   - Single Responsibility: One reason to change
   - Open/Closed: Extend with new code, not modifications
   - Liskov Substitution: Subtypes interchangeable
   - Interface Segregation: Small, focused interfaces
   - Dependency Inversion: Depend on abstractions

9. **PyInstaller for Deployment** (High)
   - Most mature freezing tool
   - One-file or one-folder mode
   - Must build on target OS (no cross-compilation)
   - tufup for secure auto-updates

10. **Responsive UI with QThread** (High)
    - Never update GUI from background thread
    - Use signals/slots for thread communication
    - QThreadPool with Worker pattern for background tasks
    - Show progress indicators for operations >100ms

11. **Structured Logging with structlog** (High)
    - JSON output for production (log aggregators)
    - Human-readable for development
    - Bind context (user_id, request_id)
    - Log to stdout, let infrastructure handle routing

12. **Configuration via Environment** (High)
    - pydantic-settings for type-safe config
    - .env for development (not committed)
    - Environment variables for production
    - Default values for optional settings

---

**Research Complete: 2025-12-29**

This research synthesizes authoritative sources on Python GUI development with RESTful APIs, emphasizing Dave Farley's continuous delivery, Kent Beck's TDD, Alistair Cockburn's hexagonal architecture, Martin Fowler's presentation patterns, and Eric Evans' domain-driven design. The consensus ratings reflect the strength of evidence and industry adoption for each practice.
